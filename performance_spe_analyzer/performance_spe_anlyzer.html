<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTOS V2X Top-down Microarchitecture Analysis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .metric-card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .partition-level {
            display: flex;
            width: 100%;
            flex-grow: 1; /* Allow levels to take up space */
        }
        .partition-node {
            box-sizing: border-box;
            border: 2px solid white;
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            font-weight: 600;
            transition: all 0.3s ease-in-out;
            overflow: hidden;
            word-wrap: break-word;
        }
        .partition-node.has-children {
            cursor: pointer;
        }
        .partition-node.has-children:hover {
            transform: scale(1.02);
            z-index: 10;
        }
        .partition-node.active {
            border-color: #4f46e5;
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5);
        }
    </style>
</head>
<body class="p-0">
    <div class="flex flex-col h-full w-full p-4 md:p-8">
        <!-- Top section: Title, file input, and summary cards -->
        <div>
            <h1 class="text-3xl font-bold text-gray-800 mb-6 text-center">RTOS V2X Top-down Microarchitecture Analysis</h1>

            <div class="metric-card mb-6">
                <h2 class="text-xl font-semibold text-gray-700 mb-3">导入SPE性能数据【仅支持RTOSV2X hiperf SPE数据格式】<a href="https://wiki.huawei.com/domains/12565/wiki/179215/WIKI202506107091265" class="text-indigo-600 hover:underline">[微架构数据采集]</a></h2>
                <div class="flex items-center space-x-4">
                    <input type="file" id="fileInput" accept=".txt,.log" class="block w-full text-sm text-gray-500
                        file:mr-4 file:py-2 file:px-4
                        file:rounded-full file:border-0
                        file:text-sm file:font-semibold
                        file:bg-indigo-50 file:text-indigo-700
                        hover:file:bg-indigo-100
                    "/>
                    <div class="flex items-center space-x-2">
                        <button id="analyzeBtn" class="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75">分析</button>
                        <select id="coreSelector" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500" style="display: none;">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div class="metric-card text-center">
                    <h2 class="text-lg font-semibold text-gray-600">Total Instructions</h2>
                    <p id="total-instructions" class="text-3xl font-bold text-indigo-600">-</p>
                </div>
                <div class="metric-card text-center">
                    <h2 class="text-lg font-semibold text-gray-600">Total Cycles</h2>
                    <p id="total-cycles" class="text-3xl font-bold text-indigo-600">-</p>
                </div>
                <div class="metric-card text-center">
                    <h2 class="text-lg font-semibold text-gray-600">Instructions Per Cycle (IPC)</h2>
                    <p id="ipc" class="text-3xl font-bold text-indigo-600">-</p>
                </div>
            </div>
        </div>

        <!-- Chart Section: This will grow to fill remaining space -->
        <div class="metric-card flex-grow flex flex-col">
            <div id="partition-chart" class="flex-grow flex flex-col">
                 <div id="placeholder" class="text-center text-gray-500 flex items-center justify-center h-full">
                    请上传您的性能数据文件以开始分析。
                </div>
            </div>
        </div>

    </div>

    <script>
        function parsePerfData(data) {
            const allCoreData = {};
            const lines = data.trim().split('\n');
            let currentCoreKey = "core0"; // Default key for data before any core identifier
            let coreData = {};
            let coreCount = 0;
            let processingCoreData = false;

            const coreHeaderRegex = /-------------------core\s*(\d+)-------------------------/;
            const eventDataStartRegex = /count\s+name\s+\|\s+comment\s+\|\s+coverage/;

            for (const line of lines) {
                const coreMatch = line.match(coreHeaderRegex);
                if (coreMatch) {
                    if (processingCoreData || Object.keys(coreData).length > 0) { // Save previous core's data if any
                        allCoreData[currentCoreKey] = coreData;
                    }
                    currentCoreKey = `core${coreMatch[1]}`;
                    coreData = {}; // Reset for the new core
                    coreCount++;
                    processingCoreData = false; // Wait for event data start line
                    continue;
                }

                if (line.match(eventDataStartRegex)) {
                    processingCoreData = true;
                    continue;
                }

                if (!processingCoreData && !line.trim().startsWith("count") && line.includes("0x")) {
                     // This handles the case where data might appear before the first core marker for "core0"
                     // or if there's only single core data without markers
                } else if (!processingCoreData) {
                    continue; // Skip lines until we hit the data start marker for a core
                }


                const parts = line.trim().split(/\s+/);
                if (parts.length >= 2 && parts[1] && parts[1].startsWith('0x')) {
                    const value = parseFloat(parts[0].replace(/,/g, ''));
                    let key = parts[1];
                    // Standardize the key format if needed, e.g., from "0x0005" to "r0005"
                    // For now, assume the format is consistent with how `r(hex)` expects it or adjust `r(hex)`
                    // The existing code uses `r(hex)` which prepends 'r' and pads hex.
                    // So, storing keys as "0x0005" and letting `r()` handle it is fine.
                    // However, the original parsePerfData converted to 'rXXXX' format. Let's stick to that.
                    if (key.startsWith('0x')) {
                        key = 'r' + key.substring(2).padStart(4, '0');
                    } else if (key.startsWith('r')) { // Already in rXXXX format
                        const hexPart = key.substring(1);
                        key = 'r' + hexPart.padStart(4, '0');
                    }
                    coreData[key] = value;
                }
            }

            // Save the last processed core's data
            if (Object.keys(coreData).length > 0) {
                allCoreData[currentCoreKey] = coreData;
            }

            // If no core markers were found, assume single core data and put it under "core0"
            if (coreCount === 0 && Object.keys(allCoreData).length > 0 && !allCoreData["core0"] ) {
                // This case is tricky. If allCoreData has data from the loop but not under core0,
                // it means the very first coreData (initialized as currentCoreKey = "core0") got data.
                // This is correct.
            } else if (coreCount === 0 && Object.keys(coreData).length > 0 && !allCoreData["core0"]) {
                 allCoreData["core0"] = coreData; // Handles single core data without markers
            }


            // If after all processing, allCoreData is empty but coreData has entries
            // (e.g. single core data without any core markers and not hitting the first if inside loop)
            if (Object.keys(allCoreData).length === 0 && Object.keys(coreData).length > 0) {
                 allCoreData["core0"] = coreData;
            }


            return allCoreData;
        }

        function transformDataForChart(node, name) {
            const children = [];
            if (node.details) {
                for (const key in node.details) {
                    const childNode = node.details[key];
                    // Ensure value is a number and greater than 0 before adding to chart
                    const numericValue = parseFloat(childNode.value);
                    if (typeof childNode === 'object' && childNode.value !== undefined && !isNaN(numericValue) && numericValue > 0) {
                        children.push(transformDataForChart(childNode, key));
                    } else if (typeof childNode === 'number' && !isNaN(childNode) && childNode > 0) {
                         children.push({ name: key, value: childNode });
                    }
                }
            }
            const result = { name, value: parseFloat(node.value) || 0 };
            if (children.length > 0) {
                result.children = children;
            }
            return result;
        }

        // Global variables
        let allParsedData = {};
        let currentSelectedCoreId = "core0";
        let rawPerfFileText = ""; // To store the raw text content of the performance file

        function populateCoreSelector(coreKeys, selectedCoreId) {
            const selector = document.getElementById('coreSelector');
            selector.innerHTML = ''; // Clear existing options
            coreKeys.sort(); // Sort core keys for consistent order

            coreKeys.forEach(coreKey => {
                const option = document.createElement('option');
                option.value = coreKey;
                option.textContent = coreKey.replace('core', 'Core ');
                if (coreKey === selectedCoreId) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });

            if (coreKeys.length > 1) {
                selector.style.display = 'inline-block'; // Show selector if multiple cores
            } else {
                selector.style.display = 'none'; // Hide if single core or no cores
            }
        }


        function analyzeAndRender(perfTextData, coreIdToAnalyze, isInitialParse = false) {
            if (isInitialParse) {
                allParsedData = parsePerfData(perfTextData);
                rawPerfFileText = perfTextData; // Store raw text
            }

            if (Object.keys(allParsedData).length === 0) {
                alert("错误：未能解析任何性能数据。请检查文件格式。");
                document.getElementById('coreSelector').style.display = 'none'; // Hide selector
                document.getElementById('placeholder').textContent = '未能解析数据，请检查文件格式和内容。';
                document.getElementById('placeholder').style.display = 'block';
                return;
            }

            const coreKeys = Object.keys(allParsedData);
            if (!coreIdToAnalyze || !allParsedData[coreIdToAnalyze]) {
                coreIdToAnalyze = coreKeys[0]; // Default to the first available core
            }
            currentSelectedCoreId = coreIdToAnalyze;

            const events = allParsedData[coreIdToAnalyze];
            if (!events || Object.keys(events).length === 0) {
                alert(`错误：在核心 ${coreIdToAnalyze} 中没有找到事件数据。`);
                document.getElementById('placeholder').textContent = `核心 ${coreIdToAnalyze} 无有效数据。`;
                document.getElementById('placeholder').style.display = 'block';
                return;
            }

            // Normalize event keys and provide defaults
            const eventGet = (key) => events[key] || events[key.replace('r00','r')] || 0;
            const r = (hex) => eventGet('r' + hex.padStart(4, '0'));

            // Ensure essential events are present
            const r0011 = r('0011'); // Total Cycles
            if (!r0011 && r0011 !==0) { // Allow 0 cycles, but not undefined/NaN
                 alert(`错误：核心 ${coreIdToAnalyze} 的周期计数(r0011/cpu-cycles)为零或缺失，无法进行分析。`);
                 document.getElementById('placeholder').textContent = `核心 ${coreIdToAnalyze} 周期计数(r0011/cpu-cycles)缺失。`;
                 document.getElementById('placeholder').style.display = 'block';
                 return;
            }
            if (r0011 === 0) {
                console.warn(`核心 ${coreIdToAnalyze} 的周期计数(r0011/cpu-cycles)为零. 部分百分比指标可能为NaN或Infinity.`);
            }
            const r0008 = r('0008'); // Instructions Retired

            const results = {};
            results.total_instructions = r0008;
            results.total_cycles = r0011;
            results.ipc = r0011 > 0 ? r0008 / r0011 : 0;

            const Frontend_Bound = (r('2014') / (4 * r0011)) * 100;
            const Frontend_Latency = (r('201d') / r0011) * 100;
            
            const iTLB_Miss = (((r('0030') - r('002e')) * 15 + r('002e') * 100) / r0011) * 100;
            const iCache_Miss = (((r('0027') - r('0028')) * 15 + r('0028') * 100) / r0011) * 100;
            
            results.frontend_bound = {
                value: Frontend_Bound,
                details: {
                    'Frontend Latency': {
                        value: Frontend_Latency,
                        details: {
                            'iTLB Miss': {
                                value: iTLB_Miss,
                                details: {
                                    'L1 iTLB Miss': (((r('0030') - r('002e')) * 15) / r0011) * 100,
                                    'L2 iTLB Miss': ((r('002e') * 100) / r0011) * 100,
                                }
                            },
                            'iCache Miss': {
                                value: iCache_Miss,
                                details: {
                                    'L1 iCache Miss': (((r('0027') - r('0028')) * 15) / r0011) * 100,
                                    'L2 iCache Miss': ((r('0028') * 100) / r0011) * 100,
                                }
                            },
                            'BP Misp Flush': ((r('0010') * 5) / r0011) * 100,
                            'OoO Rob Flush': ((r('2013') * 5) / r0011) * 100,
                            'Static Predictor Flush': ((r('1001') * 5) / r0011) * 100,
                        }
                    },
                    'Frontend Bandwidth': { value: Frontend_Bound - Frontend_Latency }
                }
            };

            const Bad_Speculation = Math.max(0, ((r('001b') - r0008) / (4 * r0011)) * 100);
            const r0010_plus_r2013 = (r('0010') + r('2013'));
            const Branch_Misp = r0010_plus_r2013 > 0 ? Bad_Speculation * (r('0010') / r0010_plus_r2013) : 0;
            const Machine_Clears = Bad_Speculation - Branch_Misp;

            results.bad_speculation = {
                value: Bad_Speculation,
                details: {
                    'Branch Mispredicts': {
                        value: Branch_Misp,
                        details: {
                            'Indirect Branch': r('0010') > 0 ? Branch_Misp * (r('1010') / r('0010')) : 0,
                            'Push Branch': r('0010') > 0 ? Branch_Misp * ((r('1013') + r('1016')) / r('0010')) : 0,
                            'Pop Branch': r('0010') > 0 ? Branch_Misp * (r('100d') / r('0010')) : 0,
                            'Other Branch': r('0010') > 0 ? Branch_Misp * ((r('0010') - r('1010') - r('1013') - r('1016') - r('100d')) / r('0010')) : 0,
                        }
                    },
                    'Machine Clears': {
                        value: Machine_Clears,
                        details: {
                            'Nuke Flush': r('2013') > 0 ? Machine_Clears * (r('2012') / r('2013')) : 0,
                            'Other Flush': r('2013') > 0 ? Machine_Clears * ((r('2013') - r('2012')) / r('2013')) : 0,
                        }
                    }
                }
            };

            const Retiring = (r0008 / (4 * r0011)) * 100;
            results.retiring = { value: Retiring };

            const Backend_Bound = Math.max(0, 100 - Frontend_Bound - Bad_Speculation - Retiring);

            // Revised calculation for Backend_Bound components
            const raw_resource_val = r('7000');
            const raw_mem_val = r('7004') + r('7005');
            const raw_core_val = r('7001') - raw_mem_val; // Assuming r7004 & r7005 are parts of r7001 for "Core" calculation

            const adj_resource_numerator = Math.max(0, raw_resource_val);
            const adj_core_numerator = Math.max(0, raw_core_val);
            const adj_mem_numerator = Math.max(0, raw_mem_val); // Should always be >=0 if r7004, r7005 are counts

            const total_backend_indicators = adj_resource_numerator + adj_core_numerator + adj_mem_numerator;

            let Resource_Bound, Core_Bound, Memory_Bound;

            if (total_backend_indicators === 0) {
                Resource_Bound = 0;
                Core_Bound = 0;
                // If no indicators, but Backend_Bound > 0, assign Backend_Bound to "Other" or a default, or leave all as 0.
                // For now, if indicators are zero, components are zero. Backend_Bound might still be non-zero.
                // This case might need a specific "Backend_Bound_Other" category if Backend_Bound > 0.
                // Or, if Backend_Bound > 0 and total_backend_indicators is 0, it implies all Backend_Bound is "Other",
                // which is not explicitly categorized here. For simplicity, let them be 0.
                Memory_Bound = 0;
            } else {
                Resource_Bound = (adj_resource_numerator / total_backend_indicators) * Backend_Bound;
                Core_Bound = (adj_core_numerator / total_backend_indicators) * Backend_Bound;
                Memory_Bound = (adj_mem_numerator / total_backend_indicators) * Backend_Bound;
            }

            // New derived events for DTLB
            const event_0x0005 = r('0005');
            const event_0x0025 = r('0025');
            const event_0x002d = r('002d');
            const event_0x002f = r('002f');

            const L1_DTLB_Miss_Rate = event_0x0025 > 0 ? (event_0x0005 / event_0x0025) * 100 : 0; // As percentage
            const L2_DTLB_Miss_Rate = event_0x002f > 0 ? (event_0x002d / event_0x002f) * 100 : 0; // As percentage

            const Divider_Stall = (r('7002') / r0011) * 100;
            const FSU_Stall = (r('7003') / r0011) * 100;
            const Exe_Ports_Util = Core_Bound - Divider_Stall - FSU_Stall;

            results.backend_bound = {
                value: Backend_Bound,
                details: {
                    'Resource Bound': { // Children of Resource Bound need to be re-evaluated if their denominator was r7000_plus_r7001
                        value: Resource_Bound, // This is the corrected Resource_Bound
                        details: { // Denominators for these children might need to use adj_resource_numerator or similar
                            'Sync Stall': adj_resource_numerator > 0 ? (r('2010') / adj_resource_numerator) * Resource_Bound : 0, // Example: Proportion of Resource_Bound
                            'Rob Stall': adj_resource_numerator > 0 ? (r('2004') / adj_resource_numerator) * Resource_Bound : 0,
                            'Ptag Stall': adj_resource_numerator > 0 ? ((r('2006') + r('2007') + r('2008')) / adj_resource_numerator) * Resource_Bound : 0,
                            'SaveOpQ Stall': adj_resource_numerator > 0 ? (r('201e') / adj_resource_numerator) * Resource_Bound : 0,
                            'PC Buffer Stall': adj_resource_numerator > 0 ? (r('2005') / adj_resource_numerator) * Resource_Bound : 0,
                            // 'Other Stall' needs careful definition: sum of specified stalls vs total resource_val
                            // For now, let's assume r('7000') is the sum of its sub-components.
                            // If r('7000') (raw_resource_val) is the correct sum for these, then proportions are of raw_resource_val.
                            // And then these are shares of Resource_Bound.
                            // This part needs more domain knowledge on events 20xx vs 7000.
                            // Sticking to previous logic for children for now, but scaled by new Resource_Bound
                            // The original was (event / r7000_plus_r7001) * Backend_Bound.
                            // This should now be (event / raw_resource_val_for_its_category) * Specific_Bound (e.g. Resource_Bound)
                            // Assuming r('7000') is the sum of its children like r('2010'), r('2004'), etc.
                            // Let's simplify Resource Bound children for now, this is not the main issue.
                            // Placeholder:
                             'Sync Stall': (r('2010') / r0011) * 100, // As % of total cycles, then it's up to user to see if it fits Resource_Bound
                             'Rob Stall': (r('2004') / r0011) * 100,
                             'Ptag Stall': ((r('2006') + r('2007') + r('2008'))/r0011) * 100,
                             'SaveOpQ Stall': (r('201e') / r0011) * 100,
                             'PC Buffer Stall': (r('2005') / r0011) * 100,
                             // Other Stall would be Resource_Bound minus sum of above.
                        }
                    },
                    'Core Bound': { // Children of Core Bound also need re-evaluation
                        value: Core_Bound, // Corrected Core_Bound
                        details: {
                            'Divider Stall': Divider_Stall, // These are already % of r0011, seems fine
                            'FSU Stall': FSU_Stall,
                            'Exe Ports Util': {
                                value: Exe_Ports_Util, // This is Core_Bound - Divider_Stall - FSU_Stall
                                details: { // These are % of r0011
                                    'ALU BRU IssueQ Full': (r('200b') / r0011) * 100,
                                    'LS IssueQ Full': (r('200c') / r0011) * 100,
                                    'FSU IssueQ Full': (r('200d') / r0011) * 100
                                }
                            }
                        }
                    },
                    'Memory Bound': {
                        value: Memory_Bound, // Corrected Memory_Bound
                        details: (() => {
                            const load_stalls_l1_hit_approx = Math.max(0, r('7004') - r('7006'));
                            const load_stalls_l2_hit_approx = Math.max(0, r('7006') - r('7007'));
                            const load_stalls_l3_miss_or_dram = r('7007'); // Assuming r7007 is always >= 0
                            const store_stalls_total = r('7005');    // Assuming r7005 is always >= 0

                            const total_mem_sub_indicators = load_stalls_l1_hit_approx + load_stalls_l2_hit_approx + load_stalls_l3_miss_or_dram + store_stalls_total;

                            let L1_Bound_val = 0, L2_Bound_val = 0, L3_DRAM_Bound_val = 0, Store_Bound_val = 0;

                            if (total_mem_sub_indicators > 0) {
                                L1_Bound_val = (load_stalls_l1_hit_approx / total_mem_sub_indicators) * Memory_Bound;
                                L2_Bound_val = (load_stalls_l2_hit_approx / total_mem_sub_indicators) * Memory_Bound;
                                L3_DRAM_Bound_val = (load_stalls_l3_miss_or_dram / total_mem_sub_indicators) * Memory_Bound;
                                Store_Bound_val = (store_stalls_total / total_mem_sub_indicators) * Memory_Bound;
                            } else if (Memory_Bound > 0) {
                                // If Memory_Bound > 0 but no sub_indicators, assign to a default like L3/DRAM or "Other Memory"
                                // For now, they remain 0 if no indicators.
                            }

                            return {
                                'L1 Bound': {
                                    value: L1_Bound_val,
                                    details: { 'L1-DTLB Miss Rate': { value: L1_DTLB_Miss_Rate } }
                                },
                                'L2 Bound': {
                                    value: L2_Bound_val,
                                    details: { 'L2-DTLB Miss Rate': { value: L2_DTLB_Miss_Rate } }
                                },
                                'L3/DRAM Bound': { value: L3_DRAM_Bound_val }, // Made it an object for consistency
                                'Store Bound': { value: Store_Bound_val }      // Made it an object for consistency
                            };
                        })()
                    }
                }
            };

            // Filter out zero-value entries from details before rendering, unless they are specifically meant to be shown as zero.
            // This needs a recursive clean-up or careful construction.
            // For now, transformDataForChart handles filtering of values > 0 for children.
            // The DTLB rates are percentages; if 0%, they might be filtered by transformDataForChart if not handled.
            // Let's ensure transformDataForChart can handle objects with 'value' and 'details'
            // and that 'L1-DTLB Miss Rate' and 'L2-DTLB Miss Rate' are treated as final metrics.
            // The current transformDataForChart will treat L1_DTLB_Miss_Rate as a direct child if it's a number > 0.
            // If L1_DTLB_Miss_Rate is 0, it won't be shown. This might be acceptable.
            // If it needs to be shown even if 0, transformDataForChart needs adjustment or the structure should be {value: L1_DTLB_Miss_Rate}.
            // Let's make them objects with a 'value' property to be consistent.

            results.backend_bound.details['Memory Bound'].details['L1 Bound'].details['L1-DTLB Miss Rate'] = { value: L1_DTLB_Miss_Rate };
            results.backend_bound.details['Memory Bound'].details['L2 Bound'].details['L2-DTLB Miss Rate'] = { value: L2_DTLB_Miss_Rate };


            document.getElementById('total-instructions').textContent = results.total_instructions.toLocaleString();
            document.getElementById('total-cycles').textContent = results.total_cycles.toLocaleString();
            document.getElementById('ipc').textContent = results.ipc.toFixed(3);

            const topLevelMetrics = {
                frontend_bound: results.frontend_bound,
                bad_speculation: results.bad_speculation,
                retiring: results.retiring,
                backend_bound: results.backend_bound,
            };
            
            const chartData = Object.keys(topLevelMetrics).map(key => {
                 const name = key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                 return transformDataForChart(topLevelMetrics[key], name);
            });

            renderCustomPartitionChart(chartData);
        }

        function renderCustomPartitionChart(data) {
            const chartContainer = document.getElementById('partition-chart');
            const placeholder = document.getElementById('placeholder');
            if(placeholder) placeholder.style.display = 'none';
            chartContainer.innerHTML = '';

            const levelColors = [
                ['#5470c6', '#fac858', '#ee6666', '#91cc75'],
                ['#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
                ['#2a9d8f', '#e9c46a', '#f4a261', '#e76f51'],
                ['#8ecae6', '#219ebc', '#023047', '#ffb703', '#fb8500']
            ];

            const createLevel = (nodes, depth, parentValue) => {
                if (!nodes || nodes.length === 0) return;

                const levelContainer = document.createElement('div');
                levelContainer.className = 'partition-level';
                levelContainer.dataset.depth = depth;

                nodes.forEach((node, index) => {
                    const nodeEl = document.createElement('div');
                    const percentage = (node.value / parentValue) * 100;
                    nodeEl.style.width = `${percentage}%`;
                    nodeEl.classList.add('partition-node');

                    const colorPalette = levelColors[depth] || levelColors[levelColors.length - 1];
                    nodeEl.style.backgroundColor = colorPalette[index % colorPalette.length];

                    nodeEl.innerHTML = `<div>${node.name}</div><div class="text-sm opacity-80">${node.value.toFixed(2)}%</div>`;

                    if (node.children && node.children.length > 0) {
                        nodeEl.classList.add('has-children');
                        nodeEl.addEventListener('click', (e) => {
                            e.stopPropagation();

                            let nextLevel = levelContainer.nextElementSibling;
                            while(nextLevel && parseInt(nextLevel.dataset.depth) > depth) {
                                const toRemove = nextLevel;
                                nextLevel = nextLevel.nextElementSibling;
                                toRemove.remove();
                            }

                            if (!nodeEl.classList.contains('active')) {
                                nodeEl.parentElement.childNodes.forEach(child => child.classList.remove('active'));
                                nodeEl.classList.add('active');
                                const childrenContainer = createLevel(node.children, depth + 1, node.value);
                                if(childrenContainer) levelContainer.after(childrenContainer);
                            } else {
                                nodeEl.classList.remove('active');
                            }
                        });
                    }
                    levelContainer.appendChild(nodeEl);
                });
                return levelContainer;
            }

            const topLevelContainer = createLevel(data, 0, 100);
            chartContainer.appendChild(topLevelContainer);
        }

        document.getElementById('analyzeBtn').addEventListener('click', () => {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        // Reset global state for new file analysis
                        allParsedData = {};
                        rawPerfFileText = "";
                        currentSelectedCoreId = "core0"; // Reset to default

                        analyzeAndRender(e.target.result, currentSelectedCoreId, true); // true for initial parse

                        const coreKeys = Object.keys(allParsedData);
                        if (coreKeys.length > 0) {
                            populateCoreSelector(coreKeys, currentSelectedCoreId);
                        } else {
                            document.getElementById('coreSelector').style.display = 'none';
                        }
                    } catch (error) {
                        console.error("分析数据时出错:", error);
                        alert("分析文件时发生错误。请检查控制台获取详细信息。");
                        document.getElementById('coreSelector').style.display = 'none';
                    }
                };
                reader.readAsText(file);
            } else {
                alert('请先选择一个文件。');
            }
        });

        document.getElementById('coreSelector').addEventListener('change', function() {
            const selectedCore = this.value;
            if (rawPerfFileText && allParsedData[selectedCore]) {
                 // Clear existing chart before rendering new core data
                const chartContainer = document.getElementById('partition-chart');
                chartContainer.innerHTML = '<div id="placeholder" class="text-center text-gray-500 flex items-center justify-center h-full">加载核心数据中...</div>';

                // Call analyzeAndRender, false for isInitialParse as data is already parsed
                analyzeAndRender(rawPerfFileText, selectedCore, false);
            }
        });
    </script>
</body>
</html>
